import datetime
from dateutil import parser

from elasticsearch_dsl import field
from elasticsearch_dsl.exceptions import ValidationException
from elasticsearch_dsl.utils import AttrList, AttrDict


class CustomMappingMixin(object):
    """ Mixin that allows to define custom ES field mapping.

    Set mapping to "_custom_mapping" attribute. Defaults to None, in
    which case default field mapping is used. Custom mapping extends
    default mapping.
    """
    _custom_mapping = None

    def __init__(self, *args, **kwargs):
        if 'mapping' in kwargs:
            self._custom_mapping = kwargs.pop('mapping')
        super(CustomMappingMixin, self).__init__(*args, **kwargs)

    def to_dict(self, *args, **kwargs):
        data = super(CustomMappingMixin, self).to_dict(*args, **kwargs)
        if self._custom_mapping is not None:
            data.update(self._custom_mapping)
        return data


class BaseFieldMixin(object):
    _valid_kwargs = ('primary_key', 'required', 'multi')

    def __init__(self, *args, **kwargs):
        self._init_kwargs = kwargs.copy()
        kwargs = self.drop_invalid_kwargs(kwargs)
        self._primary_key = kwargs.pop('primary_key', False)
        if self._primary_key:
            kwargs['required'] = True
        super(BaseFieldMixin, self).__init__(*args, **kwargs)

    def drop_invalid_kwargs(self, kwargs):
        return {key: val for key, val in kwargs.items()
                if key in self._valid_kwargs}


class IdField(CustomMappingMixin, BaseFieldMixin, field.String):
    """ Field that stores ID generated by ES. """
    name = 'idfield'
    _custom_mapping = {'type': 'string'}

    def __init__(self, *args, **kwargs):
        kwargs['primary_key'] = True
        super(IdField, self).__init__(*args, **kwargs)
        self._required = False

    def _empty(self):
        return None

    def _to_python(self, data):
        try:
            data = str(data)
        except:
            pass
        return super(IdField, self)._to_python(data)


class IntervalField(CustomMappingMixin, BaseFieldMixin, field.Integer):
    """ Custom field that stores `datetime.timedelta` instances.

    Values are stored as seconds in ES and loaded by
    `datetime.timedelta(seconds=<value>) when restoring from ES.
    """
    _coerce = True

    def _to_python(self, data):
        if isinstance(data, int):
            return datetime.timedelta(seconds=data)
        return super(IntervalField, self)._to_python(data)


class CustomInnerObjectWrapper(field.InnerObjectWrapper):
    def to_dict(self, *args, **kwargs):
        return super(CustomInnerObjectWrapper, self).to_dict()


class DictField(CustomMappingMixin, BaseFieldMixin, field.Object):
    name = 'dict'
    _custom_mapping = {'type': 'object', 'enabled': False}

    def __init__(self, *args, **kwargs):
        super(DictField, self).__init__(*args, **kwargs)
        self._doc_class = CustomInnerObjectWrapper


class DateTimeField(CustomMappingMixin, BaseFieldMixin, field.Field):
    name = 'datetime'
    _coerce = True
    _custom_mapping = {'type': 'date', 'format': 'dateOptionalTime'}

    def _to_python(self, data):
        if not data:
            return None
        if isinstance(data, datetime.datetime):
            return data
        try:
            return parser.parse(data)
        except Exception as e:
            raise ValidationException(
                'Could not parse datetime from the value (%r)' % data, e)


class DateField(CustomMappingMixin, BaseFieldMixin, field.Date):
    _custom_mapping = {'type': 'date', 'format': 'dateOptionalTime'}


class TimeField(CustomMappingMixin, BaseFieldMixin, field.Field):
    name = 'time'
    _coerce = True
    _custom_mapping = {'type': 'date', 'format': 'HH:mm:ss'}

    def _to_python(self, data):
        if not data:
            return None
        if isinstance(data, datetime.time):
            return data
        if isinstance(data, datetime.datetime):
            return data.time()
        try:
            return parser.parse(data).time()
        except Exception as e:
            raise ValidationException(
                'Could not parse time from the value (%r)' % data, e)


class IntegerField(CustomMappingMixin, BaseFieldMixin, field.Integer):
    pass


class SmallIntegerField(CustomMappingMixin, BaseFieldMixin, field.Integer):
    pass


class StringField(CustomMappingMixin, BaseFieldMixin, field.String):
    pass


class TextField(CustomMappingMixin, BaseFieldMixin, field.String):
    pass


class UnicodeField(CustomMappingMixin, BaseFieldMixin, field.String):
    pass


class UnicodeTextField(CustomMappingMixin, BaseFieldMixin, field.String):
    pass


class BigIntegerField(CustomMappingMixin, BaseFieldMixin, field.Long):
    pass


class BooleanField(CustomMappingMixin, BaseFieldMixin, field.Boolean):
    pass


class FloatField(CustomMappingMixin, BaseFieldMixin, field.Float):
    pass


class BinaryField(CustomMappingMixin, BaseFieldMixin, field.Byte):
    pass


class DecimalField(CustomMappingMixin, BaseFieldMixin, field.Double):
    pass


class ReferenceField(BaseFieldMixin, field.String):
    _backref_prefix = 'backref_'
    _coerce = False
    _back_populates = None
    _is_backref = False
    _valid_kwargs = ('required', 'multi')

    def __init__(self, doc_class, *args, **kwargs):
        prefix_len = len(self._backref_prefix)
        self._backref_kwargs = {
            key[prefix_len:]: val for key, val in kwargs.items()
            if key.startswith(self._backref_prefix)}
        for key in self._backref_kwargs:
            del kwargs[self._backref_prefix + key]
        self._doc_class = doc_class
        super(ReferenceField, self).__init__(*args, **kwargs)

    def drop_invalid_kwargs(self, kwargs):
        valid_kw = list(self._valid_kwargs)
        valid_kw += [self._backref_prefix + key for key in valid_kw]
        return {key: val for key, val in kwargs.items()
                if key in valid_kw}

    @property
    def _doc_class(self):
        from .meta import get_document_cls
        return get_document_cls(self._doc_class_name)

    @_doc_class.setter
    def _doc_class(self, name):
        self._doc_class_name = name

    def empty(self):
        if not self._required:
            return AttrList([]) if self._multi else None
        return super(ReferenceField, self).empty()

    def clean(self, data):
        types = (self._doc_class, list, AttrDict, AttrList)
        if not isinstance(data, types):
            return data
        return super(ReferenceField, self).clean(data)


def Relationship(document, **kwargs):
    # XXX deal with updating, deleting rules
    _init_kwargs = kwargs.copy()
    _init_kwargs['document'] = document
    kwargs['multi'] = kwargs.pop('uselist', True)
    kwargs['doc_class'] = document
    field = ReferenceField(**kwargs)
    field._init_kwargs = _init_kwargs
    return field


# Naive versions of fields needed to test example projects

class ListField(CustomMappingMixin, BaseFieldMixin, field.String):
    def __init__(self, *args, **kwargs):
        kwargs['multi'] = True
        super(ListField, self).__init__(*args, **kwargs)


class ForeignKeyField(CustomMappingMixin, BaseFieldMixin, field.String):
    pass


class ChoiceField(CustomMappingMixin, BaseFieldMixin, field.String):
    pass


class PickleField(CustomMappingMixin, BaseFieldMixin, field.String):
    _coerce = True

    def _to_python(self, data):
        if not data:
            return data

        import pickle
        import six
        if isinstance(data, six.binary_type):
            return pickle.loads(data)
        return pickle.dumps(data)
